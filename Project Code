# -*- coding: utf-8 -*-
"""Project OOP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JLugmJDzwFk3OeLxkqsG-v7WUT5i0AE2
"""

from abc import ABC, abstractmethod

class User(ABC):
    def __init__(self, f_name, l_name, ID, email, role, password, balance=0):
        self.f_name = f_name
        self.l_name = l_name
        self.email = email
        self.role = role
        self._password = None
        self.password = password
        self.balance = balance
        self.ID = ID

    @property
    def password(self):
        return "*" * len(self._password)# Password property to hide actual password

    @password.setter # Password setter with validation
    def password(self, new_password):
        try:
            if len(new_password) < 6 or len(new_password)>12:
                raise ValueError("Password must be between 6 and 12 characters long!")
            self._password = new_password
        except ValueError as e:
            print(f"Error: {e}")

    @password.deleter  # Prevents password deletion
    def password(self):
        raise AttributeError("Password cannot be deleted")

    def __eq__(self, other):
        if isinstance(other, User):
            return self.ID == other.ID
        return False

    @abstractmethod
    def get_details(self):
        pass

class Student(User):
    def __init__(self, f_name, l_name, id, email, role, password, balance, year):
        super().__init__(f_name, l_name, id, email, role, password, balance)
        self.year = year
    def get_details(self):
        return f"Student: {self.f_name}, {self.l_name}, ID: {self.ID}, Balance: $ {self.balance}, Year: {self.year}"

class Teacher(User):
    def __init__(self, f_name, l_name, ID, email, role, password, balance, department):
        super().__init__(f_name, l_name, ID, email, role, password, balance)
        self.department = department
        self.VIP_access = True
    def get_details(self):
        return f"Teacher: {self.f_name}, {self.l_name}, ID: {self.ID}, Balance: $ {self.balance}, Access: {self.VIP_access}"


from abc import ABC, abstractmethod

class Club(ABC):
    number_of_events = 0 # Tracks total events across all clubs
    total_budget = 50000 #Sdu life budget
    def __init__(self, club_name, description, head_of_Club):
        self.club_name = club_name
        self.description = description
        self.head_of_Club = head_of_Club
        self.events = [] # List of events organized by the club


    def add_event(self, event): #Adds a new event to the club
        self.events.append(event)
        Club.number_of_events += 1

    @classmethod
    def update_budget(cls, new_budget):
        cls.total_budget += new_budget

    @staticmethod # Calculates budget per event
    def calculate_budget_per_event():
        try:
            return int(Club.total_budget / Club.number_of_events)
        except ZeroDivisionError:
            print("It's impossible to divide by zero")
    @abstractmethod # Abstract method for getting club details
    def get_details(self):
        pass

class StandardClub(Club):
    def get_details(self):
        return f"Club: {self.club_name}, Head: {self.head_of_Club}, Description: {self.description}, Events: {len(self.events)}"

class Event(Club):
    # Location capacities
    LOCATION_CAPACITY = {
        "Red Hall": 2,
        "Mini Red Hall": 2,
        "Blue Hall": 5}

    def __init__(self, club_name, description, head_of_Club, event_name, date, location, ticket_price):
        super().__init__(club_name, description, head_of_Club)
        self.event_name = event_name
        self.date = date
        self.location = location
        self.ticket_price = ticket_price
        self.capacity = self.LOCATION_CAPACITY.get(location, 0)
        self.attendees = []  # List of attendees

    def available_spots(self): # Checks available spots for the event

        return self.capacity - len(self.attendees)

from datetime import date

class VIPMember(Student, StandardClub):
    def __init__(self, f_name, l_name, ID, email, role, password, balance, year,  club_name, activation_date ):
        Student.__init__(self, f_name, l_name, ID, email, role, password, balance, year)
        StandardClub.__init__(self,  club_name, description=None, head_of_Club = None)
        self.activation_date = activation_date if activation_date else date.today()
        self.expiration_date = date(self.activation_date.year + 1, self.activation_date.month,self.activation_date.day)  # 1-year limit

    def is_vip_active(self):
        return date.today() <= self.expiration_date  # Checks if membership is still valid

    def get_details(self):
        return f"VIPMember: {self.f_name}, Club: {self.l_name}, Student ID: {self.ID}, Balance: ${self.balance}"

class TicketSystem(Event):
    def __init__(self, club_name, description, head_of_Club, event_name, date, location, ticket_price):
        super().__init__(club_name, description, head_of_Club, event_name, date, location, ticket_price)
        self.tickets_sold = 0
        self._revenue = 0

    @classmethod
    def add_revenue_to_budget(cls, amount): # Adds ticket revenue to the SDU life's budget
        """ Transfers ticket revenue to the club's budget """
        Club.update_budget(amount)
        print(f"üí∞ {amount} added to the SDU life's budget. New total budget: {Club.total_budget}")

    def purchase_ticket(self, user):
        try:
            if user.ID in self.attendees:
                print(f"‚ùå  (ID: {user.ID}) is already registered for '{self.event_name}'.")
                return

            if isinstance(user, VIPMember) and not user.is_vip_active():
                print(f"‚ùå {user.f_name}'s VIP membership has expired! Please renew to get free entry.")
                return

            if len(self.attendees) < self.capacity:  # Check if there is space available
                if isinstance(user, Teacher) or (isinstance(user, VIPMember) and user.is_vip_active()):  # VIP & Teachers get free entry
                    print(f"‚úÖ {user.f_name} gets FREE entry to {self.event_name}!")
                    self.attendees.append(user.ID)
                elif user.ID not in self.attendees and user.balance >= self.ticket_price:  # Regular students must pay
                    user.balance -= self.ticket_price
                    self.attendees.append(user.ID)
                    self.tickets_sold += 1
                    self._revenue = self.tickets_sold * self.ticket_price
                    self.add_revenue_to_budget(self.ticket_price)
                    print(f"üéüÔ∏è {user.f_name} successfully bought a ticket for {self.event_name}.")
                else:
                    print(f"‚ùå Sorry, {user.f_name} does not have enough balance to buy a ticket!")
            else:
                print(f"‚ùå Sorry, {self.event_name} at {self.location} is sold out!")
        except AttributeError as e:
            print(f"‚ö†Ô∏è Error: Missing required attribute in user object - {e}")
        except TypeError as e:
            print(f"‚ö†Ô∏è Error: Invalid user type provided - {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Unexpected error occurred: {e}")

    def refund_ticket(self, user):
        """Allow a user to cancel their ticket and get a refund"""
        try:
            if user.ID in self.attendees:
                self.attendees.remove(user.ID)
                self.tickets_sold -= 1

                # Refund only if the user is a regular student who paid
                if not isinstance(user, (Teacher, VIPMember)):
                    user.balance += self.ticket_price
                    Club.total_budget -= self.ticket_price
                    print(f"üîÑ {user.f_name} has canceled their ticket for {self.event_name}. Refund issued.")
                else:
                    print(f"üîÑ {user.f_name} has canceled their ticket for {self.event_name}. No refund needed.")

            else:
                print(f"‚ùå {user.f_name} does not have a ticket for {self.event_name}.")
        except AttributeError:
            print("Error: Invalid user data!")

    def revenue(self):
        return self.ticket_price * self.tickets_sold

    def get_details(self):
        return (f"Event: {self.event_name}, Club: {self.club_name},  "
                f"Location: {self.location}, Date: {self.date}, Ticket Price: {self.ticket_price}, "
                f"Tickets Sold: {self.tickets_sold}, Available spots: {self.available_spots()}")



#Creating objects for testing

# Creating a Student

student1 = Student("Alibi", "Yeltay", 230317072, "alibieltai200531@gmail.com", "Student", "Ystyq23123456", 1500, 2)
print(student1.password)
student2 = Student('Madina','Abutalipkyzy',230317069,'MadinAbutalip@gmail.com','Student','Madina2006',2000,2)

# Creating a Teacher

teacher1 = Teacher("Akniyet", "Issain", 190317024, "AkniyetIssain@gmail.com", "Teacher", "Physgram", 2000, "Physics")
teacher2 = Teacher("Nazarali", "Aitzhanov", 170317012, "NazaraliAitzhanov@gmail.com", "Teacher", "Foreverphys", 2500, "Physics")

# Creating a Standard Club

club1 = StandardClub("Oyan", "Theatre", "Bakbergen")
club2 = StandardClub('Language','Teaching and learning','Akbota')

# Creating a VIP Member (who is both a Student and a Club member)

vip_member1 = VIPMember("Zhanerke", "Satin", 230317069, "ZhanerkeSatin@gmail.com", "Member of the club", "Zhanerke06", 3000, 3,  "New Generation", date(2023,3,31))
vip_member2 = VIPMember("Arystan","Sultanbek",230317085,'ArysSultanbek@gmail.com','Head of the club','Arys2006',5000,2,'Art Therapy', date(2025,3,29))

# Creating an Event under a Club
event1 = TicketSystem("Oyan", "Performance about the conference where business people gather and share their stories of orphanhood", "Bakbergen", 'The poor rich people', "2025-04-10", "Blue Hall", 600)
event2 = TicketSystem('Language','How to learn language efficiently?','Akbota','L-luxury style of learning','2025-04-11','Mini Red Hall',500)

# Adding event to the club
club1.add_event(event1)
club2.add_event(event2)

event1.purchase_ticket(teacher1)
event2.purchase_ticket(teacher2)

event1.purchase_ticket(student1)
event2.purchase_ticket(student2)
event1.purchase_ticket(student2)

event1.purchase_ticket(vip_member1)
event2.purchase_ticket(vip_member2)
#All these purchase_ticket methods implement
#  the main idea to buy a ticket



Club.update_budget(50000)#adding money to total budget

print(club1.get_details())  # Club1 details
print(event1.get_details())

print(club2.get_details())  # Club2 details
print(event2.get_details())

print(f'Oyan has revenue from event: {event1.revenue()}')
#each club has own revenue according to price of the event
print(f'Language has revenue from event: {event2.revenue()}')


event1.refund_ticket(student1)
#refunding ticket in this way our balance remains unchanged
print(student1.balance)

event2.refund_ticket(teacher2)
#but the teacher's balance isn't touched totally
print(Club.calculate_budget_per_event())

print(student1==student2)
#comparing two IDs by overloading operator




